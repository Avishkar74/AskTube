[
  {
    "video_id": "GuyZspG3-Po",
    "chunk_id": 1,
    "token_estimate": 219,
    "transcript_hash": "5f7e5b52ea30af685b4b06187fc65c31",
    "text": "Hey guys, welcome back to the channel. Today we're diving into an insane new AI tool, Z.AI chat, powered by the GLM 4.6 and GLM 4.5 models. This platform is absolutely loaded with features. You can create AI powered slides to instantly generate professional PPTs, and it even comes with ready-made templates and HTML code output. Next up, the magic design option lets you create stunning social media banners and post designs in seconds. There's also a deep research mode and a codewriting feature for developers. And the highlight, you can even build full stack applications using the full stack option just like lovable or bolt. The best part, it's completely free and open source. I'll select the full stack option and paste my prompt here. I'm building an Excel to JSON converter website with database integration and authentication. Just hit the submit button. The GLM 4.6 model is analyzing our prompt and setting up the project. You can see it's using Nex.js, Tailwind CSS, shed CN UI, and Prisma with SQL light setup as well. Now, it has created a to-do list and it's executing each step one by one. The first to-do is installing the Excel SX library which is used to read Excel files. See, it started installing and now it has moved on to the next task, updating the Prisma schema. That one's completed, too. Next, it's moving to the to-do for building the main page UI design. It's super fast. Now, only tasks number five and six are pending. We just need to wait a few seconds for them to finish. You can see the website preview appearing now. And look at that. All the to-dos are completed. Now, it's checking for any ESLint issues. So, let's wait a few seconds again. And done. The website is now fully completed."
  },
  {
    "video_id": "GuyZspG3-Po",
    "chunk_id": 2,
    "token_estimate": 215,
    "transcript_hash": "5f7e5b52ea30af685b4b06187fc65c31",
    "text": "We just need to wait a few seconds for them to finish. You can see the website preview appearing now. And look at that. All the to-dos are completed. Now, it's checking for any ESLint issues. So, let's wait a few seconds again. And done. The website is now fully completed. It has created a file upload interface, file conversion functionality, and several other useful features as well. You can see it's running on NextJS15 with TypeScript. For now, it's using SQLite by default, but we can switch to Superbase later if needed. This is the folder structure it generated. Before checking out the website, let's take a look at the code. Click on the code preview toggle button. Here's the SQL database setup. Prisma with an example schema and the Nex.js app router code all neatly organized. The folder structure is completely professional. And finally, there's the shad CN components JSON file. The best part, you can download the entire project source code. That's awesome. You can even modify it as you like and deploy it anywhere. Now we can check the website. We're able to open it in a new tab easily and see everything clearly. Let's test it. I'll upload a sample Excel file here and click submit. It instantly generates the JSON output. You can see the response. It successfully converted my Excel data into JSON format and everything looks perfect. Awesome. That's exactly what we needed. There's also an option to download the JSON file. Let's click and check. Nice. It's working perfectly. Now, if we go to the history tab, we can see the converted file history being stored. Currently, it's using the SQL light database for this. Before switching to superbase, I want to improve the UI design to make it look even better. So for that, I'll open the tweak CN website."
  },
  {
    "video_id": "GuyZspG3-Po",
    "chunk_id": 3,
    "token_estimate": 215,
    "transcript_hash": "5f7e5b52ea30af685b4b06187fc65c31",
    "text": "Nice. It's working perfectly. Now, if we go to the history tab, we can see the converted file history being stored. Currently, it's using the SQL light database for this. Before switching to superbase, I want to improve the UI design to make it look even better. So for that, I'll open the tweak CN website. Using this, we can easily customize beautiful shed CN themes. Click the start button. Here you can see all the available themes. Let's switch through them one by one to check which one suits our design best. There are a lot of great options, but I'll go with the last one. I really like this one. It's called Violet Bloom. Now click the code option. You'll see two ways to apply the theme. Either install it using PNPM or simply copy and paste the CSS code. I'll just copy the CSS code here. Now I'm going to the GLM chat, pasting the CSS code there, and hitting submit. The agent will automatically update our theme. It usually takes around 30 to 40 seconds. And done. The theme has been changed. Everything looks so much better compared to the previous version. It even includes a dark mode exactly like the one we copied. looks clean and professional now. Now we'll integrate Superbase into our project. For that, open Superbase and create a new project for the website. Once it's created, click the connect button, then go to the app framework tab. Since we're using the NextJS app router, copy the environment keys provided there. Next, go back to the agent, paste those environment keys, and also share the Next.js Superbase docs URL with it. This helps the agent understand and set up Superbase correctly. Then just type integrate Superbase and hit submit. The agent will start working on it."
  },
  {
    "video_id": "GuyZspG3-Po",
    "chunk_id": 4,
    "token_estimate": 218,
    "transcript_hash": "5f7e5b52ea30af685b4b06187fc65c31",
    "text": "Next, go back to the agent, paste those environment keys, and also share the Next.js Superbase docs URL with it. This helps the agent understand and set up Superbase correctly. Then just type integrate Superbase and hit submit. The agent will start working on it. It creates a new to-do list again and the first task is installing the necessary Superbase packages. Nice. We'll wait about a minute for that to complete. Now the agent has finished the setup, but there's one more step we need to do manually. The agent mentions that we need to open the Superbase dashboard, go to the SQL editor, and paste the provided SQL queries. So I'll copy those SQL queries now and open the SQL editor in Superbase. Here I'll paste the SQL queries and click the run button. This will generate our table inside Superbase. And there it is. We got the success message. Now open the tables menu. You can see our conversion history table has been created. Awesome. Superbase is now fully connected to our app. Next, I'll upload a sample Excel file here and click submit. It's generating the JSON output perfectly. Now if you go to the history tab, you'll notice the data is being saved, but this time it's stored in the superbase table, not in SQL light. After refreshing, the data appears instantly. Everything's working flawlessly. You can even create multiple tables in the same way if needed. Now we're going to integrate Superbase email authentication. Enter the prompt integrate off and hit submit. The agent will handle the Superbase integration automatically. We've received the new to-do list for this task. The first step is to install the authentication package. So let's wait a few seconds for that to finish. While it's installing, open Superbase. Go to authentication providers and disable the email confirmation."
  },
  {
    "video_id": "GuyZspG3-Po",
    "chunk_id": 5,
    "token_estimate": 212,
    "transcript_hash": "5f7e5b52ea30af685b4b06187fc65c31",
    "text": "Enter the prompt integrate off and hit submit. The agent will handle the Superbase integration automatically. We've received the new to-do list for this task. The first step is to install the authentication package. So let's wait a few seconds for that to finish. While it's installing, open Superbase. Go to authentication providers and disable the email confirmation. This is just for development purposes so we don't get any verification emails. You can reenable it later in production. Now the agent is creating the signin and signup pages. Once that's done, our app now requires a login to access it. But before logging in, we need to run a few SQL queries in Superbase. The GLM agent has already provided the SQL query. So, copy it and open the SQL editor in Superbase. Here, I'll paste the queries and hit the run button. You'll see an error because the history table already exists. So, go ahead and delete the previous table. Then, run the query again. This time, it works successfully. You'll notice something new. The updated history table now includes a user ID column. That means every conversion history record will be linked to the loggedin user. Now open the website and try signing up. Enter your username, email address, and password. Then click sign up. The user is created instantly. Next, log in with the same email and password. Click sign in and it works perfectly. Authentication is fully functional. Now to confirm, open the Superbase dashboard. users table. You'll see the newly created user record there. Our website is now fully integrated with Superbase authentication. Everything's connected and working smoothly. Thanks for watching. If you found this video helpful, don't forget to like, subscribe, and turn on the bell icon for more awesome tech content. See you in the next one."
  },
  {
    "video_id": "IFkDbsgn8yg",
    "chunk_id": 1,
    "token_estimate": 210,
    "transcript_hash": "e4a2fa30370395cb3610805966b00eac",
    "text": "How your microservices communicate affects your systems scalability, reliability, and complexity. I have built and maintained microservices systems for years. And in this video, I'll show you what communication styles are available and the implication of adopting each style. Microservices communication is a complex topic and this video is only the first in a series of 10 videos on this topic. By the end of this video, you'll have a good understanding of the different communication styles, but I strongly recommend you watch the entire series to get a more in-depth understanding. In the microservices architecture, each service runs independently in its own process. And to enable them to collaborate, we need an interprocess communication mechanism. One common method is direct network calls. For example, a video service sends a request to a notification service and waits for a response. This style of communication is called synchronous communication. After sending the request, the video service stops and waits until it receives a reply. It's like making a phone call. You call someone and wait for them to answer. This approach is simple and familiar. It's similar to how most web APIs work and it's kind of similar to a function call in some aspects. However, unlike function calls, network communication has extra challenges. The network can be less reliable and latency must be considered. Requests take time to travel and the cold service might be unavailable or very slow. If the notification service is down or slow, the video service gets stuck and will be unable to process other requests. This can lead to too many pending request and resource exhaustion. We'll discuss how to mitigate this in episode 3 of this series. You have the link in the description."
  },
  {
    "video_id": "IFkDbsgn8yg",
    "chunk_id": 2,
    "token_estimate": 213,
    "transcript_hash": "e4a2fa30370395cb3610805966b00eac",
    "text": "If the notification service is down or slow, the video service gets stuck and will be unable to process other requests. This can lead to too many pending request and resource exhaustion. We'll discuss how to mitigate this in episode 3 of this series. You have the link in the description. Synchronous communication is particularly suited for request response interactions and it can be a good fit for simpler microservices systems. But there is an alternative that doesn't involve blocking calls and unlocks a lot of possibilities. Instead of blocking synchronous calls, services can communicate through messages. It's like sending an email. You send it and you carry on and the receiver reads it when they can. As you can imagine, services don't send emails to each other. They could, but that would be highly unconventional to say the least and quite inefficient. So instead, a service can send a message to a channel and another service will read the message from that channel. The sender and the receiver don't need to know about each other. They only need to know about the channel. In our example, the video service sends a message to a channel and the notification service reads it. The video service doesn't wait for a response. It continues processing all the requests. This is the essence of asynchronous messaging, nonblocking communication. But a synchronous communication can get very complex. So what if the sender needs a response and how do we ensure that messages are reliably delivered and processed? A common solution is using a message broker. So a message broker is a piece of infrastructure that sits between the sender and the receiver. So the sender sends the message to the broker which delivers it to the receiver."
  },
  {
    "video_id": "IFkDbsgn8yg",
    "chunk_id": 3,
    "token_estimate": 213,
    "transcript_hash": "e4a2fa30370395cb3610805966b00eac",
    "text": "A common solution is using a message broker. So a message broker is a piece of infrastructure that sits between the sender and the receiver. So the sender sends the message to the broker which delivers it to the receiver. Message brokers handle complexities and offer features like guaranteeing at least once delivery, maintaining messaging order and broadcasting to multiple receivers and even storing messages temporarily. So messaging is a broad topic and we'll explore it further in episode 6, 7, and 8. But what if you don't want to add complex infrastructure but still need asynchronous communication? There is another method that doesn't involve network calls between services or message brokers. Something you might have encountered without even realizing it's a communication pattern. Returning to our video service example, instead of sending a message, the video service writes a new record to a database when a video is uploaded and the notification service reads from the database. For those of you who are familiar with microservices, you might be thinking, wait a minute, aren't microservices supposed to have their own database and not share databases. So the key here is to make sure that the flow of data is unidirectional. The video service writes the data and the notification service reads the data. So the notification service doesn't write to the database. This is not often considered as a communication pattern, but in practice, this is pretty much what it is. So you could consider that the video service is sending a message to a channel and the notification service is reading that message from the channel. But in this case the channel is the database or the file system. I address this topic in more details in episode 9 of this series."
  },
  {
    "video_id": "IFkDbsgn8yg",
    "chunk_id": 4,
    "token_estimate": 176,
    "transcript_hash": "e4a2fa30370395cb3610805966b00eac",
    "text": "So you could consider that the video service is sending a message to a channel and the notification service is reading that message from the channel. But in this case the channel is the database or the file system. I address this topic in more details in episode 9 of this series. As you can see there are many ways services can communicate with each other and each communication style has its own trade-offs. It's crucial that you choose the method that fits your own need. And also remember that you're not limited to one communication style. It's very common and sometimes necessary to have different types of communication inside the same system. In summary, synchronous communication is like a phone call. So you call someone and you wait for them to answer. Asynchronous messaging is like sending an email. You just press send and you just move on with your life. Asynchronous communication via shared storage is like you writing a piece of on a piece of paper and leaving it on the table for someone else to read. This is just the beginning. We haven't even discussed technologies, protocols, handling failures or dealing with breaking changes. But don't worry, this is just the first in a 10p part series on microservices communication. You can watch this video to learn more about synchronous communication styles and carry on watching the rest of the playlist to get the full picture of microservices communication."
  }
]